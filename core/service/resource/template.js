'use strict'

const App = require('../../app')
const async = require('async')
const logger = require('../../lib/logger')('service:resource:template')

const ResourceTemplateModel = require('../../entity/resource/template').Entity;
const MonitorTemplateModel = require('../../entity/monitor/template').Entity;
const MonitorModel = require('../../entity/monitor').Entity;
const ResourceModel = require('../../entity/resource').Entity;

//const MonitorService = require('./monitor')

module.exports = {
  /**
   *
   * @author Facundo
   * @param {HostGroup} hostgroup
   * @param {Array Resource} resources
   * @param {Customer} customer
   * @param {User} user
   * @param {Function} done
   *
   */
  createTemplates (hostgroup, resources, customer, user, done) {
    if (!resources) { return done(null, []) }
    if (!Array.isArray(resources) || resources.length===0) {
      return done(null, [])
    }

    logger.log('processing %s resource monitors', resources.length);

    /* create templates from input */
    async.map(
      resources,
      (resource, next) => {
        const monitor = resource.monitor

        if (!monitor) {
          const err = new Error('resource monitor data not defined')
          err.statusCode = 400
          err.resource = resource
          return next(err)
        }

        const config = Object.assign({}, monitor, monitor.config||{})
        const result = App.resourceMonitor.validateData(config)

        if (!result || result.errors) {
          const msg = 'invalid resource monitor data'
          logger.error(msg)
          const e = new Error(msg)
          e.statusCode = 400
          e.info = result.error
          return next(e)
        }

        const data = result.data
        data.customer = customer
        // DO NOT UN-COMMENT ! user property generates conflict with monitor.config.user property of monitor.type === file 
        //data.user = user
        data.hostgroup = hostgroup
        data.source_monitor_id = (resource.monitor._id || resource.monitor.id)
        data.source_resource_id = (resource._id || resource.id)

        logger.log('creating template')
        createResourceTemplate(data, next)
      },
      (err, templates) => {
        if (err) {
          logger.error('failed to create resource template')
          logger.error(err, err.resource)
          return done(err)
        }
        done(null, templates)
      }
    )
  }
}

/**
 * create resource and monito from input
 * @author Facundo
 * @param {Object} input
 * @param {Function(ErrorObject,Object)} done
 */
const createResourceTemplate = async (input, done) => {
  const data = {
    customer: input.customer._id,
    customer_id: input.customer._id,
    customer_name: input.customer.name,
    type: input.type,
    name: input.name,
    description: input.description,
  }

  // provisional model. will not persist into the database
  let monitor = await App.resourceMonitor.create( input.type, Object.assign({}, input, data) )
  let monitor_data = monitor.toObject()
  monitor_data.source_model_id = input.source_monitor_id
  delete monitor_data.host_id // not needed. just in case...
  delete monitor_data._id // must be autogenerated

  logger.log ('creating monitor template')
  // create both and link them together

  let monitorTemplate = new MonitorTemplateModel(monitor_data)
  let resourceTemplate = new ResourceTemplateModel(data)

  resourceTemplate._type = 'ResourceTemplate'
  resourceTemplate.monitor_template = monitorTemplate
  resourceTemplate.monitor_template_id = monitorTemplate._id
  resourceTemplate.source_model_id = input.source_resource_id
  resourceTemplate.hostgroup = input.hostgroup
  resourceTemplate.hostgroup_id = input.hostgroup._id

  monitorTemplate._type = 'MonitorTemplate'
  monitorTemplate.template_resource = resourceTemplate
  monitorTemplate.template_resource_id = resourceTemplate._id
  monitorTemplate.hostgroup = input.hostgroup
  monitorTemplate.hostgroup_id = input.hostgroup._id

  await monitorTemplate.save()
  await resourceTemplate.save()
  logger.log('all templates created')
  done(null, resourceTemplate)
}
